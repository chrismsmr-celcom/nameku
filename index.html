<!doctype html>
<html lang="fr">
<head> <link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#000000">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NAMEKU ‚Äî Arcade Pack 1</title>
  <style>
    :root{
      --bg:#071014;
      --panel:#081420;
      --neon:#6bff6b;
      --muted:#98a6b3;
      --accent:#22c55e;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;background:
      radial-gradient(circle at 10% 10%, rgba(34,197,94,0.04), transparent 6%),
      linear-gradient(180deg,#071014 0%, #041017 100%); color:#e6ffe6; font-family: "Press Start 2P", monospace, system-ui, sans-serif; -webkit-font-smoothing: none; -moz-osx-font-smoothing: grayscale;}
    .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:28px;}
    .card{display:grid;grid-template-columns:1fr 320px;gap:18px;background:linear-gradient(180deg, rgba(0,0,0,0.25), rgba(255,255,255,0.02)); padding:18px;border-radius:14px;box-shadow:0 10px 50px rgba(0,0,0,0.7);border:2px solid rgba(120,250,120,0.03);backdrop-filter: blur(2px);}
    .screen-wrap{position:relative;display:flex;align-items:center;justify-content:center;padding:12px;background:linear-gradient(180deg, rgba(10,20,10,0.6), rgba(0,0,0,0.6));border-radius:10px;transition: transform .25s ease;}
    .screen-wrap.shake{animation: miso-shake .45s}
    @keyframes miso-shake{0%{transform:translateX(0)}20%{transform:translateX(-8px)}40%{transform:translateX(8px)}60%{transform:translateX(-6px)}80%{transform:translateX(6px)}100%{transform:translateX(0)}}
    canvas{display:block; image-rendering: pixelated; width:100%; height:100%; border-radius:6px; background: linear-gradient(180deg,#0b1b0b, #071018);}
    .screen-wrap::after{
      content:"";
      pointer-events:none;
      position:absolute; inset:12px; border-radius:6px;
      background-image:
        repeating-linear-gradient(180deg, rgba(0,0,0,0.03) 0px, rgba(0,0,0,0.02) 1px),
        radial-gradient(1200px 400px at 50% 10%, rgba(255,255,255,0.03), transparent 10%),
        linear-gradient(180deg, rgba(0,0,0,0.15), rgba(0,0,0,0.35));
      mix-blend-mode: multiply;
    }
    h1{font-size:18px;margin:0 0 6px;color:var(--neon); text-shadow: 0 0 8px rgba(100,255,100,0.12);}
    .muted{color:var(--muted);font-size:12px}
    .sidebar{width:320px;padding-left:6px;display:flex;flex-direction:column;gap:8px}
    .row{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
    .small{font-size:11px;color:#dff0dff0}
    .info{background:var(--glass);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    button{background:linear-gradient(180deg,var(--accent), #1a8f43);border:none;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(34,197,94,0.06);font-size:11px}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--neon)}
    #start{animation: pulse 1.6s infinite}
    @keyframes pulse {0%{transform:scale(1)}50%{transform:scale(1.04)}100%{transform:scale(1)}}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;visibility:visible;opacity:1;transition:.25s;z-index:80}
    .insert-coin{color:var(--neon);font-size:20px;text-align:center;line-height:1.6}
    .insert-coin .blink{animation: blink 1s steps(1) infinite}
    @keyframes blink{50%{opacity:0}}
    .insert-coin small{display:block;font-size:10px;color:var(--muted);margin-top:6px}
    .overlay.hidden{visibility:hidden;opacity:0;pointer-events:none}
    .menu{background:linear-gradient(180deg,#061217,#07121a);padding:18px;border-radius:12px;box-shadow:0 12px 50px rgba(0,0,0,0.7);text-align:center;border:1px solid rgba(100,255,100,0.06)}
    .menu h2{margin:0 0 12px;color:var(--neon);text-shadow:0 0 6px rgba(100,255,100,0.08)}
    .badge{font-size:10px;padding:6px;border-radius:6px;background:linear-gradient(180deg,#05220b,#08320e);border:1px solid rgba(255,255,255,0.03);display:inline-block}
    footer{font-size:10px;color:var(--muted);margin-top:10px}
    #score,#best,#timer{font-weight:800;font-size:18px;color:var(--neon); text-shadow:0 0 8px rgba(110,255,110,0.04)}
    .small-list{font-size:11px;color:#dfffdc;line-height:1.3;padding:8px;background:rgba(255,255,255,0.01);border-radius:8px;max-height:120px;overflow:auto}
    .muted-note{font-size:10px;color:var(--muted)}
    @media(max-width:900px){ .card{grid-template-columns:1fr 220px} .sidebar{width:220px} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="Jeu Snake arcade">
      <div class="screen-wrap screen-shadow" id="screenWrap" style="width:520px; height:520px;">
        <canvas id="game" width="320" height="320" aria-label="Zone de jeu"></canvas>
      </div>

      <aside class="sidebar">
        <h1>NAMEKU ARCADE üêç </h1>
        

        <div class="row">
          <div>
            <div class="small">Score</div>
            <div id="score">0</div>
          </div>
          <div>
            <div class="small">Record</div>
            <div id="best">0</div>
          </div>
        </div>

        <div class="row">
          <div>
            <div class="small">Temps</div>
            <div id="timer">50</div>
          </div>
          <div class="badge">Arcade version</div>
        </div>

        <div class="row">
          <button id="start">D√©marrer</button>
          <button id="pause" class="ghost">Pause</button>
        </div>

        <div class="info small">
          <div style="margin-bottom:6px">Vitesse (cases/sec)</div>
          <label><input id="speedRange" type="range" min="4" max="30" value="10"></label>
        </div>

        <div style="height:6px"></div>
        <div class="small">Param√®tres</div>
        <label class="small">Grille: <span id="gridSizeLabel">24</span>x<span id="gridSizeLabel2">24</span></label>
        <input id="gridRange" type="range" min="12" max="48" value="24">

        <div style="height:6px"></div>
        <div class="small">Historique (5 derniers)</div>
        <div id="lastList" class="small-list">‚Äî aucun score ‚Äî</div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
          <button id="muteBtn" class="ghost">üîä</button>
          <div class="muted-note">Press R pour red√©marrer ‚Äî P pour pause</div>
        </div>

        <footer>
          Retro mode ‚Ä¢by namekucode -- MKMdeveloper
        </footer>
      </aside>
    </div>
  </div>

  <!-- INSERT COIN Overlay -->
  <div id="insertOverlay" class="overlay">
    <div class="insert-coin">
    <NAMEKU SNACK></small>
      <div class="blink">INSERT COIN</div>
      <small>Appuie sur ENTR√âE ou sur D√©marrer pour jouer ‚Äî Version Arcade Pack 1</small>
    </div>
  </div>

  <!-- Menu Game Over -->
  <div id="overlay" class="overlay hidden" style="z-index:90;">
    <div class="menu" id="menuPanel">
      <h2>GAME OVER</h2>
      <p>Score: <span id="finalScore">0</span></p>
      <p>Meilleur: <span id="finalBest">0</span></p>
      <button id="restartBtn">Rejouer</button>
    </div>
  </div>

  <script>
    /******** Elements ********/
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const startBtn = document.getElementById('start');
    const pauseBtn = document.getElementById('pause');
    const speedRange = document.getElementById('speedRange');
    const gridRange = document.getElementById('gridRange');
    const gridLabel = document.getElementById('gridSizeLabel');
    const gridLabel2 = document.getElementById('gridSizeLabel2');
    const timerEl = document.getElementById('timer');
    const insertOverlay = document.getElementById('insertOverlay');
    const overlay = document.getElementById('overlay');
    const finalScoreEl = document.getElementById('finalScore');
    const finalBestEl = document.getElementById('finalBest');
    const restartBtn = document.getElementById('restartBtn');
    const lastList = document.getElementById('lastList');
    const muteBtn = document.getElementById('muteBtn');
    const screenWrap = document.getElementById('screenWrap');
    const menuPanel = document.getElementById('menuPanel');

    /******** State ********/
    let gridSize = parseInt(gridRange.value,10);
    let cellPx = 12;
    let timeLeft = 50;
    let timerInterval;
    let isMuted = false;
    let startedFromInsert = false;

    const state = {
      running: false,
      paused: false,
      score: 0,
      best: Number(localStorage.getItem('snake_best') || 0),
      lastScores: JSON.parse(localStorage.getItem('snake_scores') || '[]'), // array of last scores
      speed: Number(speedRange.value),
      dir: {x:1,y:0},
      nextDir: null,
      snake: [],
      snakeSet: new Set(),
      apple: null,
      appleType: 'normal', // 'normal' | 'gold'
      cols: gridSize,
      rows: gridSize
    };

    // update best and list UI
    bestEl.textContent = state.best;
    renderLastScores();

    /******** Audio (WebAudio) ********/
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    function ensureAudio(){
      if(!audioCtx){ audioCtx = new AudioCtx(); }
    }
    function playTone(freq=880, time=0.08, type='square', vol=0.06){
      if(isMuted) return;
      try{
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = vol;
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
        o.stop(audioCtx.currentTime + time + 0.01);
      }catch(e){}
    }
    function jingleIntro(){
      if(isMuted) return;
      try{
        ensureAudio();
        const now = audioCtx.currentTime;
        const o1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        o1.type='square'; o1.frequency.value = 880;
        g1.gain.value = 0.06;
        o1.connect(g1); g1.connect(audioCtx.destination);
        o1.start(now);
        g1.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
        o1.stop(now + 0.13);

        const o2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        o2.type='square'; o2.frequency.value = 1320;
        g2.gain.value = 0.06;
        o2.connect(g2); g2.connect(audioCtx.destination);
        o2.start(now + 0.14);
        g2.gain.exponentialRampToValueAtTime(0.0001, now + 0.26);
        o2.stop(now + 0.27);

        const o3 = audioCtx.createOscillator();
        const g3 = audioCtx.createGain();
        o3.type='square'; o3.frequency.value = 660;
        g3.gain.value = 0.06;
        o3.connect(g3); g3.connect(audioCtx.destination);
        o3.start(now + 0.28);
        g3.gain.exponentialRampToValueAtTime(0.0001, now + 0.42);
        o3.stop(now + 0.43);
      }catch(e){}
    }

    /******** Utilities ********/
    const encodePos = (x,y) => (x<<16) | y;

    function saveScore(score){
      // push to front, keep max 5
      state.lastScores.unshift(score);
      if(state.lastScores.length > 5) state.lastScores = state.lastScores.slice(0,5);
      localStorage.setItem('snake_scores', JSON.stringify(state.lastScores));
    }

    function renderLastScores(){
      if(!state.lastScores || state.lastScores.length === 0){
        lastList.textContent = '‚Äî aucun score ‚Äî';
        return;
      }
      lastList.innerHTML = state.lastScores.map((s,i)=>`${i+1}. ${s}`).join('<br>');
    }

    /******** Game logic ********/
    function resetGame(){
      state.cols = gridSize;
      state.rows = gridSize;
      state.snake.length = 0;
      state.snakeSet.clear();
      const midX = Math.floor(state.cols/2);
      const midY = Math.floor(state.rows/2);
      for(let i=0;i<4;i++){
        const x = midX - i; const y = midY;
        state.snake.push({x,y});
        state.snakeSet.add(encodePos(x,y));
      }
      state.dir = {x:1,y:0};
      state.nextDir = null;
      placeApple();
      state.score = 0;
      updateScoreUI();
    }

    function placeApple(){
      // choose a free spot
      const total = state.cols * state.rows;
      if(state.snake.length >= total){ state.apple = null; return; }
      for(let attempt=0; attempt<64; attempt++){
        const x = Math.floor(Math.random()*state.cols);
        const y = Math.floor(Math.random()*state.rows);
        const code = encodePos(x,y);
        if(!state.snakeSet.has(code)) {
          // determine if gold apple (1 chance on 8)
          const isGold = (Math.random() < 1/8);
          state.apple = {x,y};
          state.appleType = isGold ? 'gold' : 'normal';
          return;
        }
      }
      for(let y=0;y<state.rows;y++){
        for(let x=0;x<state.cols;x++){
          const code = encodePos(x,y);
          if(!state.snakeSet.has(code)) { state.apple = {x,y}; state.appleType = 'normal'; return; }
        }
      }
    }

    function update(){
      if(!state.running || state.paused) return;
      if(state.nextDir){
        const nd = state.nextDir;
        if(!(nd.x === -state.dir.x && nd.y === -state.dir.y)){
          state.dir = nd;
        }
        state.nextDir = null;
      }
      const head = state.snake[0];
      const nx = head.x + state.dir.x;
      const ny = head.y + state.dir.y;
      const hx = (nx + state.cols) % state.cols;
      const hy = (ny + state.rows) % state.rows;
      const code = encodePos(hx,hy);
      const tail = state.snake[state.snake.length-1];
      const tailCode = encodePos(tail.x, tail.y);
      const willGrow = (state.apple && hx === state.apple.x && hy === state.apple.y);

      if(state.snakeSet.has(code) && (!willGrow || code !== tailCode)){
        playTone(220,0.38,'sawtooth',0.12);
        gameOver();
        return;
      }
      state.snake.unshift({x:hx,y:hy});
      state.snakeSet.add(code);
      if(willGrow){
        if(state.appleType === 'gold'){
          state.score += 2; // gold apple gives +2 points
          playTone(1500,0.08,'triangle',0.12);
        } else {
          state.score += 1;
          playTone(1200,0.06,'square',0.09);
        }
        updateScoreUI();
        placeApple();
      } else {
        const removed = state.snake.pop();
        state.snakeSet.delete(encodePos(removed.x, removed.y));
      }
    }

    function gameOver(){
      state.running = false;
      state.paused = true;
      clearInterval(timerInterval);
      // save best and last scores
      if(state.score > state.best){
        state.best = state.score;
        localStorage.setItem('snake_best', state.best);
      }
      saveScore(state.score);
      localStorage.setItem('snake_best', state.best);
      bestEl.textContent = state.best;
      finalScoreEl.textContent = state.score;
      finalBestEl.textContent = state.best;
      renderLastScores();
      overlay.classList.remove('hidden');
      // shake screen and small sound
      screenWrap.classList.add('shake');
      menuPanel.classList.remove('shake');
      setTimeout(()=>{ menuPanel.classList.add('shake'); }, 40);
      setTimeout(()=>{ screenWrap.classList.remove('shake'); }, 600);
      playTone(220,0.5,'sawtooth',0.13);
    }

    function updateScoreUI(){ scoreEl.textContent = state.score; }

    /******** Rendering (retro) ********/
    let lastTime = performance.now();
    let accumulator = 0;

    function render(){
      // crisp pixels
      ctx.imageSmoothingEnabled = false;

      const cols = state.cols;
      const rows = state.rows;
      cellPx = Math.floor(canvas.width / Math.max(cols, rows));
      const gridW = cellPx * cols;
      const gridH = cellPx * rows;
      const offsetX = Math.floor((canvas.width - gridW)/2);
      const offsetY = Math.floor((canvas.height - gridH)/2);

      // background
      ctx.fillStyle = '#071018';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // panel background gradient
      const g = ctx.createLinearGradient(0, offsetY, 0, offsetY+gridH);
      g.addColorStop(0,'#0b2212');
      g.addColorStop(1,'#071018');
      ctx.fillStyle = g;
      ctx.fillRect(offsetX, offsetY, gridW, gridH);

      // subtle checkerboard
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          if(((x+y)&1)===0){
            ctx.fillStyle = 'rgba(16,40,16,0.04)';
            ctx.fillRect(offsetX + x*cellPx, offsetY + y*cellPx, cellPx, cellPx);
          }
        }
      }

      // apple (gold or normal), add pulse for gold
      if(state.apple){
        const ax = offsetX + state.apple.x*cellPx;
        const ay = offsetY + state.apple.y*cellPx;
        if(state.appleType === 'gold'){
          // gold apple: warmer color + glow square
          const pulse = 0.2 + 0.1 * Math.sin(performance.now() / 200);
          const pad = Math.max(1, Math.floor(cellPx * (0.08 + pulse)));
          ctx.fillStyle = '#ffd36b';
          ctx.fillRect(ax + 1, ay + 1, cellPx-2, cellPx-2);
          ctx.fillStyle = 'rgba(255,255,200,0.7)';
          ctx.fillRect(ax + pad, ay + pad, cellPx-2*pad, cellPx-2*pad);
          // small sparkle
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.fillRect(ax + 1, ay + 1, Math.max(1,Math.floor(cellPx*0.15)), Math.max(1,Math.floor(cellPx*0.15)));
        } else {
          const pulse = 0.12 + 0.08 * Math.sin(performance.now() / 220);
          const pad = Math.max(1, Math.floor(cellPx*0.12 + cellPx*pulse));
          ctx.fillStyle = '#ff6161';
          ctx.fillRect(ax + 1, ay + 1, cellPx-2, cellPx-2);
          ctx.fillStyle = 'rgba(255,200,200,0.5)';
          ctx.fillRect(ax + pad, ay + pad, cellPx-2*pad, cellPx-2*pad);
        }
      }

      // snake (head different)
      for(let i=state.snake.length-1;i>=0;i--){
        const s = state.snake[i];
        const x = offsetX + s.x*cellPx + 1;
        const y = offsetY + s.y*cellPx + 1;
        if(i===0){
          ctx.fillStyle = '#9ff69f';
          ctx.fillRect(x, y, cellPx-2, cellPx-2);
          // eye
          const ex = x + Math.floor(cellPx*0.6);
          const ey = y + Math.floor(cellPx*0.3);
          ctx.fillStyle = '#05210a';
          ctx.fillRect(ex, ey, Math.max(1,Math.floor(cellPx*0.15)), Math.max(1,Math.floor(cellPx*0.15)));
        } else {
          const alpha = 0.85 - Math.min(0.6, i/state.snake.length);
          ctx.fillStyle = `rgba(34,197,94,${alpha})`;
          ctx.fillRect(x, y, cellPx-2, cellPx-2);
        }
      }

      // top/bottom subtle vignettes
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(0,0,canvas.width,offsetY+Math.floor(cellPx*0.4));
      ctx.fillRect(0,offsetY+gridH-Math.floor(cellPx*0.4),canvas.width, Math.floor(cellPx*0.4));
    }

    function loop(now){
      const delta = Math.min(200, now - lastTime);
      lastTime = now;
      const ticksPerSecond = state.speed;
      const secondsPerTick = 1 / ticksPerSecond;
      accumulator += delta / 1000;
      let updates = 0;
      while(accumulator >= secondsPerTick && updates < 4){
        update();
        accumulator -= secondsPerTick;
        updates++;
      }
      render();
      requestAnimationFrame(loop);
    }

    /******** Input handling (keys + touch) ********/
    const keyMap = new Map([
      ['ArrowUp',{x:0,y:-1}], ['ArrowDown',{x:0,y:1}], ['ArrowLeft',{x:-1,y:0}], ['ArrowRight',{x:1,y:0}],
      ['w',{x:0,y:-1}], ['s',{x:0,y:1}], ['a',{x:-1,y:0}], ['d',{x:1,y:0}]
    ]);

    window.addEventListener('keydown',(e)=>{
      if(e.repeat) return;
      const key = e.key;
      if(key === 'Enter'){
        if(!state.running && insertOverlay.style.visibility !== 'hidden'){
          // start from insert screen
          insertOverlay.classList.add('hidden');
          startGame(true);
          return;
        } else if(!state.running && overlay.classList.contains('hidden')){
          startGame();
          return;
        }
      }
      if(key === 'p' || key === 'P'){ togglePause(); return; }
      if(key === 'r' || key === 'R'){ startGame(); return; }
      const dir = keyMap.get(key);
      if(dir){ state.nextDir = dir; e.preventDefault(); }
    }, {passive:false});

    // touch swipe
    let touchStart = null;
    window.addEventListener('touchstart',(ev)=>{ const t = ev.touches[0]; touchStart = {x:t.clientX, y:t.clientY}; }, {passive:true});
    window.addEventListener('touchend',(ev)=>{ if(!touchStart) return; const t = ev.changedTouches[0]; const dx = t.clientX - touchStart.x; const dy = t.clientY - touchStart.y; if(Math.abs(dx) > Math.abs(dy)){ if(dx>20) state.nextDir={x:1,y:0}; else if(dx<-20) state.nextDir={x:-1,y:0}; } else { if(dy>20) state.nextDir={x:0,y:1}; else if(dy<-20) state.nextDir={x:0,y:-1}; } touchStart = null; }, {passive:true});

    /******** UI hooks ********/
    startBtn.addEventListener('click', ()=> {
      insertOverlay.classList.add('hidden');
      startGame();
    });
    pauseBtn.addEventListener('click', ()=> {
      if(!state.running) startGame(); else togglePause();
    });
    restartBtn.addEventListener('click', ()=> {
      overlay.classList.add('hidden');
      startGame();
    });

    speedRange.addEventListener('input', (e)=>{ state.speed = Number(e.target.value); });
    gridRange.addEventListener('input', (e)=>{ gridSize = Number(e.target.value); gridLabel.textContent = gridSize; gridLabel2.textContent = gridSize; });

    muteBtn.addEventListener('click', ()=> {
      isMuted = !isMuted;
      muteBtn.textContent = isMuted ? 'üîá' : 'üîä';
    });

    function togglePause(){
      if(!state.running){ startGame(); return; }
      state.paused = !state.paused;
      pauseBtn.textContent = state.paused ? 'Reprendre' : 'Pause';
    }

    /******** Start / Timer logic (50s) ********/
    function startGame(fromInsert = false){
      startedFromInsert = !!fromInsert;
      state.running = true;
      state.paused = false;
      pauseBtn.textContent = 'Pause';
      state.speed = Number(speedRange.value);
      state.cols = state.rows = gridSize;
      resetGame();
      lastTime = performance.now();
      accumulator = 0;
      overlay.classList.add('hidden');

      // Timer
      clearInterval(timerInterval);
      timeLeft = 50;
      timerEl.textContent = timeLeft;
      timerInterval = setInterval(()=>{
        if(state.running && !state.paused){
          timeLeft--;
          timerEl.textContent = timeLeft;
          if(timeLeft <= 0){
            clearInterval(timerInterval);
            gameOver();
          }
        }
      },1000);

      // intro jingle when starting from insert coin
      if(fromInsert){
        jingleIntro();
        // small delay to feel the insert coin -> start
        setTimeout(()=> playTone(660,0.06,'square',0.06), 360);
      } else {
        playTone(660,0.06,'square',0.06);
      }
    }

    /******** Resize canvas for crisp pixels ********/
    function resizeCanvas(){
      const wrapper = canvas.parentElement;
      const displayW = wrapper.clientWidth - 24;
      const displayH = wrapper.clientHeight - 24;
      const size = Math.min(displayW, displayH);
      const cols = Math.max(12, state.cols || gridSize);
      let scale = Math.floor(size / Math.max(cols, 12));
      if(scale < 2) scale = 2;
      if(scale > 12) scale = 12;
      const internalSize = cols * scale;
      canvas.style.width = internalSize + 'px';
      canvas.style.height = internalSize + 'px';
      canvas.width = internalSize;
      canvas.height = internalSize;
    }
    window.addEventListener('resize', resizeCanvas);

    // initial: show insert coin overlay
    function init(){
      insertOverlay.classList.remove('hidden');
      overlay.classList.add('hidden');
      renderLastScores();
      resizeCanvas();
      requestAnimationFrame(loop);
    }

    init();
  </script>
</body>
</html>

